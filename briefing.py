#!/usr/bin/env python3
"""Generate hierarchical BRIEF.md — a compact index, not a dump.

Target: ~50-80 lines. Organized by domain (brain regions).
Points down to kb.py for deep lookups, doesn't duplicate the full graph.
"""

import sqlite3
import os
from datetime import datetime, timezone

DB_PATH = os.path.expanduser("~/.claude/knowledge/knowledge.db")
BRIEF_PATH = os.path.expanduser("~/.claude/knowledge/BRIEF.md")

# Domain detection from source field patterns
DOMAIN_RULES = [
    ("KH", ["kaufmann-health", "kaufmann/health", "kaufmann%health"]),
    ("Personal", ["Personal-Support", "Personal/Support", "cornell", "email-katherine"]),
    ("VSS", ["vss"]),
    ("IsAI", ["IsAIConsciousYet", "isai"]),
    ("Infrastructure", ["claude-sessions", "knowledge-base", "kkauf"]),
]


def detect_domain(source: str) -> str:
    """Map a source string to a domain name."""
    source_lower = source.lower()
    for domain, patterns in DOMAIN_RULES:
        for pat in patterns:
            if pat.lower() in source_lower:
                return domain
    return "Other"


def generate():
    if not os.path.exists(DB_PATH):
        with open(BRIEF_PATH, 'w') as f:
            f.write("<!-- Auto-generated by knowledge-base. Do not edit manually. -->\n")
            f.write("# Knowledge Brief\n\nNo facts recorded yet.\n")
        return

    db = sqlite3.connect(DB_PATH)
    db.row_factory = sqlite3.Row

    now = datetime.now(timezone.utc)
    lines = []
    lines.append("<!-- Auto-generated by knowledge-base. Do not edit manually. -->")
    lines.append(f"<!-- Generated: {now.strftime('%Y-%m-%d %H:%M UTC')} -->")
    lines.append("")

    # --- Stats ---
    entity_count = db.execute("SELECT COUNT(*) FROM entities").fetchone()[0]
    fact_count = db.execute("SELECT COUNT(*) FROM facts WHERE valid_to IS NULL").fetchone()[0]
    relation_count = db.execute("SELECT COUNT(*) FROM relations WHERE valid_to IS NULL").fetchone()[0]
    decision_count = db.execute("SELECT COUNT(*) FROM decisions WHERE status = 'active'").fetchone()[0]

    lines.append(f"# Knowledge Brief ({entity_count} entities, {fact_count} facts)")
    lines.append("")

    # --- Domain summary table ---
    # Build domain stats from source field on facts
    domain_stats = {}  # domain -> {entities: set, facts: int, latest_fact: str}
    facts_with_source = db.execute("""
        SELECT f.entity_id, f.source, f.attribute, f.value, f.created_at, e.name
        FROM facts f JOIN entities e ON f.entity_id = e.id
        WHERE f.valid_to IS NULL
        ORDER BY f.created_at DESC
    """).fetchall()

    for row in facts_with_source:
        domain = detect_domain(row['source'] or '')
        if domain not in domain_stats:
            domain_stats[domain] = {"entities": set(), "facts": 0, "latest_entity": None, "latest_date": None}
        domain_stats[domain]["entities"].add(row['entity_id'])
        domain_stats[domain]["facts"] += 1
        if domain_stats[domain]["latest_entity"] is None:
            # First row per domain is latest (ordered by created_at DESC)
            domain_stats[domain]["latest_entity"] = row['name']
            domain_stats[domain]["latest_date"] = row['created_at'][:10] if row['created_at'] else ""

    lines.append("## Domains")
    lines.append("| Region | Entities | Facts | Last updated |")
    lines.append("|--------|----------|-------|--------------|")
    for domain in ["KH", "Personal", "Infrastructure", "VSS", "IsAI", "Other"]:
        if domain in domain_stats:
            s = domain_stats[domain]
            latest = f"{s['latest_entity']} ({s['latest_date']})" if s['latest_entity'] else ""
            lines.append(f"| {domain} | {len(s['entities'])} | {s['facts']} | {latest} |")
    lines.append("")

    # --- Key Numbers (high-value metrics from top entities) ---
    key_entities = ["Kaufmann Health", "Cal.com", "Konstantin Kaufmann"]
    key_attrs = [
        "booking_value", "conversion_rate", "conversion_multiplier",
        "cal_live_therapists", "leads_per_30d", "cost_per_lead",
        "primary_conversion_signal", "north_star_metric",
    ]

    key_facts = db.execute("""
        SELECT e.name, f.attribute, f.value
        FROM facts f JOIN entities e ON f.entity_id = e.id
        WHERE f.valid_to IS NULL
        AND e.name IN ({})
        AND f.attribute IN ({})
        ORDER BY e.name, f.attribute
    """.format(
        ",".join(["?"] * len(key_entities)),
        ",".join(["?"] * len(key_attrs)),
    ), key_entities + key_attrs).fetchall()

    if key_facts:
        lines.append("## Key Numbers")
        for row in key_facts:
            lines.append(f"- **{row['name']}** {row['attribute']}: {row['value']}")
        lines.append("")

    # --- Recent Decisions (7 days) ---
    decisions = db.execute("""
        SELECT title, rationale, decided_at FROM decisions
        WHERE status = 'active'
        AND decided_at > date('now', '-7 days')
        ORDER BY decided_at DESC
        LIMIT 10
    """).fetchall()

    if decisions:
        lines.append("## Recent Decisions (7d)")
        for d in decisions:
            rationale = f" — {d['rationale'][:80]}" if d['rationale'] else ""
            lines.append(f"- **{d['title']}** ({d['decided_at']}){rationale}")
        lines.append("")

    # --- Top entities per domain (max 5 entities, max 3 facts each) ---
    MAX_ENTITIES_PER_DOMAIN = 5
    MAX_FACTS_PER_ENTITY = 3

    # Get entities ranked by fact count, grouped by domain
    entity_domain_map = {}  # entity_id -> primary domain (from most-facts source)
    for row in facts_with_source:
        eid = row['entity_id']
        domain = detect_domain(row['source'] or '')
        if eid not in entity_domain_map:
            entity_domain_map[eid] = {}
        entity_domain_map[eid][domain] = entity_domain_map[eid].get(domain, 0) + 1

    # Resolve primary domain per entity
    entity_primary_domain = {}
    for eid, domains in entity_domain_map.items():
        entity_primary_domain[eid] = max(domains, key=domains.get)

    # Get top entities by fact count
    top_entities = db.execute("""
        SELECT e.id, e.name, e.type, COUNT(f.id) as fact_count
        FROM entities e
        JOIN facts f ON f.entity_id = e.id AND f.valid_to IS NULL
        GROUP BY e.id
        ORDER BY fact_count DESC
    """).fetchall()

    # Group by domain
    domain_entities = {}  # domain -> [(name, type, fact_count, entity_id)]
    for e in top_entities:
        domain = entity_primary_domain.get(e['id'], 'Other')
        if domain not in domain_entities:
            domain_entities[domain] = []
        if len(domain_entities[domain]) < MAX_ENTITIES_PER_DOMAIN:
            domain_entities[domain].append(e)

    for domain in ["KH", "Personal", "Infrastructure", "VSS", "IsAI", "Other"]:
        entities = domain_entities.get(domain, [])
        if not entities:
            continue

        lines.append(f"## {domain}")
        for e in entities:
            facts = db.execute("""
                SELECT attribute, value FROM facts
                WHERE entity_id = ? AND valid_to IS NULL
                ORDER BY created_at DESC
                LIMIT ?
            """, (e['id'], MAX_FACTS_PER_ENTITY)).fetchall()

            fact_str = " | ".join(f"{f['attribute']}={f['value'][:50]}" for f in facts)
            lines.append(f"- **{e['name']}** ({e['type']}, {e['fact_count']}f): {fact_str}")
        lines.append("")

    # --- Footer ---
    lines.append("---")
    lines.append(f"*{relation_count} relations, {decision_count} active decisions.*")
    lines.append(f"*Deep lookup: `kb.py query \"entity\"` | `kb.py search \"term\"` | `kb.py decisions`*")

    db.close()

    with open(BRIEF_PATH, 'w') as f:
        f.write('\n'.join(lines) + '\n')

    print(f"Generated {BRIEF_PATH} ({len(lines)} lines, {entity_count} entities, {fact_count} facts)")


if __name__ == '__main__':
    generate()
