#!/usr/bin/env python3
"""Generate hierarchical BRIEF.md — a compact index, not a dump.

Target: ~50-80 lines. Organized by domain (brain regions).
Points down to kb.py for deep lookups, doesn't duplicate the full graph.
"""

import sqlite3
import os
from datetime import datetime, timezone

DB_PATH = os.path.expanduser("~/.claude/knowledge/knowledge.db")
BRIEF_PATH = os.path.expanduser("~/.claude/knowledge/BRIEF.md")

# Domain detection from source field patterns (used for new facts without entity_domains entry)
DOMAIN_RULES = [
    ("KH", ["kaufmann-health", "kaufmann/health", "kaufmann%health"]),
    ("Personal", ["Personal-Support", "Personal/Support", "cornell", "email-katherine"]),
    ("VSS", ["vss"]),
    ("IsAI", ["IsAIConsciousYet", "isai"]),
    ("Infrastructure", ["claude-sessions", "knowledge-base", "kkauf"]),
]

DOMAIN_ORDER = ["KH", "Personal", "Infrastructure", "VSS", "IsAI", "Other"]


def detect_domain(source: str) -> str:
    """Map a source string to a domain name."""
    source_lower = source.lower()
    for domain, patterns in DOMAIN_RULES:
        for pat in patterns:
            if pat.lower() in source_lower:
                return domain
    return "Other"


def generate():
    if not os.path.exists(DB_PATH):
        with open(BRIEF_PATH, 'w') as f:
            f.write("<!-- Auto-generated by knowledge-base. Do not edit manually. -->\n")
            f.write("# Knowledge Brief\n\nNo facts recorded yet.\n")
        return

    db = sqlite3.connect(DB_PATH)
    db.row_factory = sqlite3.Row

    now = datetime.now(timezone.utc)
    lines = []
    lines.append("<!-- Auto-generated by knowledge-base. Do not edit manually. -->")
    lines.append(f"<!-- Generated: {now.strftime('%Y-%m-%d %H:%M UTC')} -->")
    lines.append("")

    # --- Stats ---
    entity_count = db.execute("SELECT COUNT(*) FROM entities").fetchone()[0]
    fact_count = db.execute("SELECT COUNT(*) FROM facts WHERE valid_to IS NULL").fetchone()[0]
    relation_count = db.execute("SELECT COUNT(*) FROM relations WHERE valid_to IS NULL").fetchone()[0]
    decision_count = db.execute("SELECT COUNT(*) FROM decisions WHERE status = 'active'").fetchone()[0]

    lines.append(f"# Knowledge Brief ({entity_count} entities, {fact_count} facts)")
    lines.append("")

    # --- Domain summary from entity_domains table ---
    has_domains = db.execute(
        "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='entity_domains'"
    ).fetchone()[0] > 0

    domain_stats = {}
    if has_domains:
        for row in db.execute("""
            SELECT ed.domain,
                   COUNT(DISTINCT ed.entity_id) as entities,
                   COUNT(f.id) as facts,
                   MAX(f.created_at) as latest_at
            FROM entity_domains ed
            LEFT JOIN facts f ON f.entity_id = ed.entity_id AND f.valid_to IS NULL
            WHERE ed.confidence >= 0.5
            GROUP BY ed.domain
            ORDER BY facts DESC
        """):
            domain_stats[row['domain']] = {
                "entities": row['entities'],
                "facts": row['facts'],
                "latest_at": row['latest_at'],
            }

        # Get latest entity name per domain
        for domain in domain_stats:
            latest = db.execute("""
                SELECT e.name FROM entity_domains ed
                JOIN entities e ON ed.entity_id = e.id
                JOIN facts f ON f.entity_id = e.id AND f.valid_to IS NULL
                WHERE ed.domain = ? AND ed.confidence >= 0.5
                ORDER BY f.created_at DESC LIMIT 1
            """, (domain,)).fetchone()
            domain_stats[domain]["latest_entity"] = latest['name'] if latest else ""

    lines.append("## Domains")
    lines.append("| Region | Entities | Facts | Last updated |")
    lines.append("|--------|----------|-------|--------------|")
    for domain in DOMAIN_ORDER:
        if domain in domain_stats:
            s = domain_stats[domain]
            date = s['latest_at'][:10] if s['latest_at'] else ""
            latest = f"{s['latest_entity']} ({date})" if s['latest_entity'] else ""
            lines.append(f"| {domain} | {s['entities']} | {s['facts']} | {latest} |")
    lines.append("")

    # --- Key Numbers (high-value metrics from top entities) ---
    key_entities = ["Kaufmann Health", "Cal.com", "Konstantin Kaufmann"]
    key_attrs = [
        "booking_value", "conversion_rate", "conversion_multiplier",
        "cal_live_therapists", "leads_per_30d", "cost_per_lead",
        "primary_conversion_signal", "north_star_metric",
    ]

    key_facts = db.execute("""
        SELECT e.name, f.attribute, f.value
        FROM facts f JOIN entities e ON f.entity_id = e.id
        WHERE f.valid_to IS NULL
        AND e.name IN ({})
        AND f.attribute IN ({})
        ORDER BY e.name, f.attribute
    """.format(
        ",".join(["?"] * len(key_entities)),
        ",".join(["?"] * len(key_attrs)),
    ), key_entities + key_attrs).fetchall()

    if key_facts:
        lines.append("## Key Numbers")
        for row in key_facts:
            lines.append(f"- **{row['name']}** {row['attribute']}: {row['value']}")
        lines.append("")

    # --- Recent Decisions (7 days) ---
    decisions = db.execute("""
        SELECT title, rationale, decided_at FROM decisions
        WHERE status = 'active'
        AND decided_at > date('now', '-7 days')
        ORDER BY decided_at DESC
        LIMIT 10
    """).fetchall()

    if decisions:
        lines.append("## Recent Decisions (7d)")
        for d in decisions:
            rationale = f" — {d['rationale'][:80]}" if d['rationale'] else ""
            lines.append(f"- **{d['title']}** ({d['decided_at']}){rationale}")
        lines.append("")

    # --- Top entities per domain (max 5 entities, max 3 facts each) ---
    MAX_ENTITIES_PER_DOMAIN = 5
    MAX_FACTS_PER_ENTITY = 3

    for domain in DOMAIN_ORDER:
        if domain not in domain_stats:
            continue

        if has_domains:
            top = db.execute("""
                SELECT e.id, e.name, e.type, COUNT(f.id) as fact_count
                FROM entity_domains ed
                JOIN entities e ON ed.entity_id = e.id
                JOIN facts f ON f.entity_id = e.id AND f.valid_to IS NULL
                WHERE ed.domain = ? AND ed.confidence >= 0.5
                GROUP BY e.id
                ORDER BY fact_count DESC
                LIMIT ?
            """, (domain, MAX_ENTITIES_PER_DOMAIN)).fetchall()
        else:
            top = []

        if not top:
            continue

        lines.append(f"## {domain}")
        for e in top:
            facts = db.execute("""
                SELECT attribute, value FROM facts
                WHERE entity_id = ? AND valid_to IS NULL
                ORDER BY created_at DESC
                LIMIT ?
            """, (e['id'], MAX_FACTS_PER_ENTITY)).fetchall()

            fact_str = " | ".join(f"{f['attribute']}={f['value'][:50]}" for f in facts)
            lines.append(f"- **{e['name']}** ({e['type']}, {e['fact_count']}f): {fact_str}")
        lines.append("")

    # --- Footer ---
    lines.append("---")
    lines.append(f"*{relation_count} relations, {decision_count} active decisions.*")
    lines.append(f"*Deep lookup: `kb.py query \"entity\"` | `kb.py search \"term\"` | `kb.py domain \"KH\"`*")

    db.close()

    with open(BRIEF_PATH, 'w') as f:
        f.write('\n'.join(lines) + '\n')

    print(f"Generated {BRIEF_PATH} ({len(lines)} lines, {entity_count} entities, {fact_count} facts)")


if __name__ == '__main__':
    generate()
